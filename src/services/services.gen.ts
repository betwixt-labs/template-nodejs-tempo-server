//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.7.0
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord } from "bebop";
import {MethodType} from "@tempojs/common"
import { ServiceRegistry, BaseService, ServerContext, BebopMethodAny, BebopMethod } from "@tempojs/server";

/**
 * `HelloRequest` is a struct representing a request to the Greeter service.
 */
export interface IHelloRequest extends BebopRecord {
  /**
   * The name to be used in the greeting.
   * It is of type string.
   */
  name: string;
}

export class HelloRequest implements IHelloRequest {
  public name: string;

  constructor(record: IHelloRequest) {
    this.name = record.name;
  }

  public encode(): Uint8Array {
    return HelloRequest.encode(this);
  }

  public static encode(record: IHelloRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloRequest, view: BebopView): number {
    const before = view.length;
    view.writeString(record.name);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloRequest {
    let field0: string;
    field0 = view.readString();
    let message: IHelloRequest = {
      name: field0,
    };
    return new this(message);
  }
}

/**
 * `HelloResponse` is a struct representing the response from the Greeter service.
 */
export interface IHelloResponse extends BebopRecord {
  /**
   * The greeting message generated by the service.
   * It is of type string.
   */
  serviceMessage: string;
}

export class HelloResponse implements IHelloResponse {
  public serviceMessage: string;

  constructor(record: IHelloResponse) {
    this.serviceMessage = record.serviceMessage;
  }

  public encode(): Uint8Array {
    return HelloResponse.encode(this);
  }

  public static encode(record: IHelloResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloResponse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.serviceMessage);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloResponse {
    let field0: string;
    field0 = view.readString();
    let message: IHelloResponse = {
      serviceMessage: field0,
    };
    return new this(message);
  }
}

/**
 * `Greeter` is a service that provides methods for generating greeting messages.
 */
/**
 * `Greeter` is a service that provides methods for generating greeting messages.
 */
export abstract class BaseGreeterService extends BaseService {
  public static readonly serviceName = 'GreeterService';
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  public abstract sayHello(record: IHelloRequest, context: ServerContext): Promise<IHelloResponse>;
  /**
   * `sayHelloClient` is a method that takes a stream of `HelloRequest` and returns a `HelloResponse`.
   * It is used for client-side streaming.
   */
  public abstract sayHelloClient(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): Promise<IHelloResponse>;
  /**
   * `sayHelloServer` is a method that takes a `HelloRequest` and returns a stream of `HelloResponse`.
   * It is used for server-side streaming.
   */
  public abstract sayHelloServer(record: IHelloRequest, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
  /**
   * `sayHelloDuplex` is a method that takes a stream of `HelloRequest` and returns a stream of `HelloResponse`.
   * It is used for bidirectional streaming.
   */
  public abstract sayHelloDuplex(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
}

export class TempoServiceRegistry extends ServiceRegistry {
  private static readonly staticServiceInstances: Map<string, BaseService> = new Map<string, BaseService>();
  public static register(serviceName: string) {
    return (constructor: Function) => {
      const service = Reflect.construct(constructor, [undefined]);
      if (TempoServiceRegistry.staticServiceInstances.has(serviceName)) {
        throw new Error(`Duplicate service registered: ${serviceName}`);
      }
      TempoServiceRegistry.staticServiceInstances.set(serviceName, service);
    }
  }
  public static tryGetService(serviceName: string): BaseService {
    const service = TempoServiceRegistry.staticServiceInstances.get(serviceName);
    if (service === undefined) {
      throw new Error(`Unable to retreive service '${serviceName}' - it is not registered.`);
    }
    return service;
  }

  public init(): void {
    let service: BaseService;
    let serviceName: string;
    serviceName = 'GreeterService';
    service = TempoServiceRegistry.tryGetService(serviceName);
    if (!(service instanceof BaseGreeterService)) {
      throw new Error(`No service named '${serviceName}'was registered with the TempoServiceRegistry`);
    }
    service.setLogger(this.logger.clone(serviceName));
    TempoServiceRegistry.staticServiceInstances.delete(serviceName);
    this.serviceInstances.push(service);
    if (this.methods.has(1308554837)) {
      const conflictService = this.methods.get(1308554837)!;
      throw new Error(`GreeterService.sayHello collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(1308554837, {
      name: 'sayHello',
      service: serviceName,
      invoke: service.sayHello,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.Unary,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3429833156)) {
      const conflictService = this.methods.get(3429833156)!;
      throw new Error(`GreeterService.sayHelloClient collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3429833156, {
      name: 'sayHelloClient',
      service: serviceName,
      invoke: service.sayHelloClient,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.ClientStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3393365588)) {
      const conflictService = this.methods.get(3393365588)!;
      throw new Error(`GreeterService.sayHelloServer collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3393365588, {
      name: 'sayHelloServer',
      service: serviceName,
      invoke: service.sayHelloServer,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.ServerStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(2551291458)) {
      const conflictService = this.methods.get(2551291458)!;
      throw new Error(`GreeterService.sayHelloDuplex collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(2551291458, {
      name: 'sayHelloDuplex',
      service: serviceName,
      invoke: service.sayHelloDuplex,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.DuplexStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
  }

  getMethod(id: number): BebopMethodAny | undefined {
    return this.methods.get(id);
  }
}
